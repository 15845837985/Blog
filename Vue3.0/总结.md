# 总结

这个部分重点对我在学习中遇到的问题进行总结，会分享一些问题的解决方法，大家遇到的问题也可以留言评论一起探讨😁

## Vue3.0生命周期中的onBeforeMount:

官方文档中明确写出了onBeforeMount这个生命周期钩子 （官方文档地址：[https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html）](https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html），但当我在setup中使用onBeforeMount钩子时，会提示错误，并且在项目中查询不到该钩子，如果在setup外面，像vue)，但是当我在setup中使用onBeforeMount钩子时，会提示错误同时在项目中查询不到这个钩子，如果在setup外面，像vue 2.x中一样使用beforeMount时，虽然不会报错，但是并不会进入这个生命周期钩子。

**官方文档中解释道：因为**`setup`**是围绕**`beforeCreate`**和**`created`**生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在**`setup`**函数中编写。**

下面是beforeCreate、created和beforeMount三个生命周期钩子的解释：

### 1.beforeCreate：

vue实例中的el，data，data中的message都为undefined

### 2. created：

el还是undefined，而数据已经与data中的属性进行绑定（放在data中属性当值发生改变的同时，视图也会发生变化），在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。

### 3. beforeMount：

载入前（完成了data和el数据初始化），但是页面中的内容还是vue中的占位符，data中的message信息没有被挂在到Bom节点中，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。

### 从created到beforeMount的过程中

* 首先会判断vue实例中有没有el选项，如果有的话则进行下面的编译，但是如果没有el选项，则停止生命周期，直到vue实例上调用vm.$mount\(el\)。
* 如果有el，再判断是否有template参数，如果有，则把其当作模板编译成render函数，如果没有，则把外部的html作为模板编译。template中的模板优先级高于outer HTML模板。
* 在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.
* 综合排名优先级：render函数选项 &gt;template选项 &gt;outer HTML.

结合官方文档的解释，我猜想在vue 3.0中，setup应该是将beforeCreate、created和beforeMount三个生命周期进行了整合，完成data和el的数据初始化，此时data中的message信息没有被挂在到Bom节点中，同时提供一个在渲染前更改数据的钩子。至于onBeforeMount在setup中报错的问题，我还没有找到详细的解释，如果有谁知道欢迎留言。

## Vue3.x和Vue2.x的几个明显区别：

### \#\# data

**vue2.x**

```
data() { return{} }
```

实现响应式

* 定义在data中
* 使用Vue.set实现响应式

**vue3.x**

```
import { reactive } from 'vue'
 
setup (props) {
    const state = reactive({
      title: 'Hello Vue3.0'
    })
    return state
 }
```

实现响应式

* 从vue包中导入 toRefs 函数，导出state的时候，进行包裹。代码如下

```
setup (props) {
    const state = reactive({
      title: 'Hello Vue3.0'
    })
   return { ...toRefs(state), xxx }
 }
```

### \#\# methods

**vue2.x**

methods: { 方法 }

**vue3.x**

* 写在setup函数中，并且要return返回方法名称
* 记得要把返回的state数据，通过toRefs变成响应式的数据，否则不会起作用。代码如下

```
return {
      ...toRefs(state),
      play
 }
```

### \#\# computed

**vue2.x**

computed: {计算属性}

**vue3.x**

* 写在setup函数中。代码如下

```
const getDoubleNum = computed(() => state.num * 2)
```

*  写在state中

```
const state = reactive({
      myName: computed(() => 'my name is vue3.x')
 })
```

注意：需要从vue包中导入 computed 函数，如果是写在setup函数中，最后return的时候，返回计算属性函数



