# 一、内部排序：

  在一个排序工作的执行过程中,如果待排序的记录全部保存在内存,这种工作就称为**内排序**；针对外存\(磁盘、磁带等\)数据的排序工作称为**外排序**。内排序中的**归并排序算法**是大多数外排序算法的基础。  
  在考虑算法时,最基本的问题是其时间和空间复杂度。为了在某种合理的抽象层次上考虑它们的时间复杂度和空间复杂度，需要确定关注的基本操作，以其作为时间单位，**时间复杂性**反映排序过程中这个\(或这些\)操作的执行次数。还需确定某种抽象的空间单位。  
  现在要做的是数据记录排序,而且基于关键码比较,比较之后有可能要调整数据记录的位置\(顺序\)。根据这些情况可以确定两种最重要的基本操作：

* 比较关键码的操作,通过这种操作确定数据的顺序关系。
* 移动数据记录的操作,用于调整记录的位置和/或顺序。

  在下面讨论各种算法时,总是以被排序序列的长度\(即序列中元素的个数\)作为问题规模参数n,讨论在完成整个排序的过程中执行上述两种操作的次数\(的量级\)。以此作为评价算法效率的度量\(时间复杂度\)。  
  理论研究已经得到了一个明确的结论:基于关键码比较的排序问题，**时间复杂度**是o \( n l o g n \) o \( n l o g ⁡ n \) o \( n log ⁡ n \) o\(nlogn\)o\(nlog⁡n\) o\(n\log n\)o\(nlogn\)o\(nlog⁡n\)o\(nlogn\)Rj​的前后顺序不变，就称这种排序算法是**稳定的**。也就是说，稳定的算法能够维持序列中所有排序码相同记录的相对位置。如果一个排序算法不能保证上述条件，它就是不稳定的。  
**适应性：**如果一个排序算法对接近有序的序列工作得更快,就称这种算法具有适应性。具有适应性的算法也有实际价值，因为实际中常常需要处理接近排序的序列。

## 1.稳定的排序算法

| 稳定的排序 | 时间复杂度 | 空间复杂度 |
| :--- | :--- | :--- |
| 冒泡排序\(bubble sort\) | 最差、平均都是O\(n^2\)，最好是O\(n\) | 1 |
| 插入排序\(insertion sort\) | 最差、平均都是O\(n^2\)，最好是O\(n\) | 1 |
| 归并排序\(merge sort\) | 最差、平均、最好都是O\(n log n\) | O\(n\) |
| 桶排序\(bucket sort\) | O\(n\) | O\(k\) |
| 基数排序\(Radix sort\) | O\(nk\)（k是常数） | O\(n\) |
| 二叉树排序\(Binary tree sort\) | O\(n log n\) | O\(n\) |



