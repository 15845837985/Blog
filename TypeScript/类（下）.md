# 类（下）：

## TypeScript中的类：

```
class Person{
    pName:string;
    pAge:number;
    constructor(name:string,age:number){
        this.pName = name;
        this.pAge = age;
    }

    say():void{
        console.log(this.pName + "say hello to you");
    }
}

var p = new Person('张三',20);
p.say()
```

## ts中实现继承：

    class Person{
        pName:string;
        constructor(name:string){
            this.pName = name;
        }
        run():string{
            return `${this.pName}在运动`
        }
    }

    class Coder extends Person{
        constructor(name:string){
            super(name);  /*初始化父类构造函数*/
        }
    }

    var c = new Coder('李氏');
    console.log(c.run());

## 关于ts中继承的探讨：

当父类和子类存在相同的的方法时，会执行子类的方法。（执行方法先在子类中寻找，如果子类中有，执行子类中的方法，如果子类中没有，在父类中寻找，父类中有则执行父类中的方法）

    class Person{
        pName:string;
        constructor(name:string){
            this.pName = name;
        }
        run():string{
            return `${this.pName}在运动`
        }
    }

    class Coder extends Person{
        constructor(name:string){
            super(name);
        }
        run():string{
            return `${this.pName}在运动--子类`
        }
        work():string{
            return `${this.pName}在工作`
        }
    }

    var c = new Coder('李氏');
    console.log(c.run());
    console.log(c.work());

## 类中的修饰符：

在TyperScript中定义属性时提供了三种修饰符

分别为：

public    公有类型  在当前类里面、子类中、类外面都能访问

    class Person{
        public pName:string;
        constructor(name:string){
            this.pName = name;
        }
        run():string{
            return `${this.pName}在运动`
        }
    }

    var p = new Person('王老五');
    console.log(p.pName);

protected    保护类型  在当前类里面、子类中可以访问  在类外面没法访问

    class Person{
        protected pName:string;
        constructor(name:string){
            this.pName = name;
        }
        run():string{
            return `${this.pName}在运动`
        }
    }

    class Coder extends Person{
        constructor(name:string){
            super(name);
        }
        work():string{
            return `${this.pName}在工作`
        }
    }

    var c = new Coder('李氏');
    console.log(c.run()); //在父类中调用
    console.log(c.work()); //在子类中调用

    var p = new Person('王老五');
    console.log(p.run()); //在当前类中调用

private    私有类型  仅在当前类里面可以访问  在子类和类外面都没法访问

属性不加修饰符默认为public

    class Person{
        private pName:string;
        constructor(name:string){
            this.pName = name;
        }
        run():string{
            return `${this.pName}在运动`
        }
    }

    class Coder extends Person{
        constructor(name:string){
            super(name);
        }
        work():string{
            return `${this.pName}在工作` // 报错 不可在子类中访问
        }
    }

    var c = new Coder('李氏');
    console.log(c.run());  // 在Person中的run
    console.log(c.work());  // 报错 不可在子类中访问

    var p = new Person('王老五');
    console.log(p.run());  // 只能在类内部访问
    console.log(p.pName);  // 报错 不可在类外部访问



